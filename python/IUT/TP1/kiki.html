												{
    "author": "Dominique Revuz",
    "name": "Boites d'oeufs",
    "title": "Modulo et Diviser",
    "files": [
        {
            "name": "utils.py",
            "content": "#!\/usr\/bin\/env python3\n# -*- coding: utf-8 -*-\n#\n#  utils.py\n#\n#  Copyright 2016 Dominique Revuz <dr@univ-mlv.fr>\n#\n# help functions to use in the PL project\n#\n#\n\nimport subprocess\nimport json\nimport sys\nimport re\n\npldicsingleton=None\n\ndef getpldic():\n\t'''\n\tgetpdic return the dictionnary contained in the file \".\/pl.json\"\n\t'''\n\tglobal pldicsingleton\n\tif pldicsingleton == None :\n\t\ttry:\n\t\t\tpldicsingleton= json.load(open(\"pl.json\",\"r\"))\n\t\texcept Exception as e:\n\t\t\tpldicsingleton = {\"plateforme\":False,\n\t\t\t\t\"stderr\":e,\"result\":False,\n\t\t\t\t\"stdout\":\"PlateForme IO ERROR\"}\n\treturn pldicsingleton\n\n\nglobtaboook=False # par defaut pas de problem de taboo\n\n# le checktaboo doit \u00eatre fait en debut de grader\ndef checktaboo(taboo):\n\t\"\"\"\n\tcheck taboo est brutal\n\til faudrais faire une analyse du code pour\n\t\u00eatre sur que les mots clefs sont vraiment des mots clef\n\tpas des truc ou les loup 'bass' sont transform\u00e9e en 'bbotom'.\n\t\"\"\"\n\tltaboo = taboo.split('|')\n\tmots = (open(\"student.py\",\"r\").read()).split() #\n\tfor x in ltaboo:\n\t\tif x in mots:\n\t\t\tglobtaboook = True\n\treturn globtaboook\n\n\n\ndef check_output(want, got):\n\t\"\"\"\n\tReturn True iff the actual output from an example (`got`)\n\tmatches the expected output (`want`).\n\n\t\"\"\"\n\n\t# If `want` contains hex-escaped character such as \"\\u1234\",\n\t# then `want` is a string of six characters(e.g. [\\,u,1,2,3,4]).\n\t# On the other hand, `got` could be another sequence of\n\t# characters such as [\\u1234], so `want` and `got` should\n\t# be folded to hex-escaped ASCII string to compare.\n\t# FIXME i commanted out the 2 following lignes\n\tgot = str(pldecode(got).encode('ASCII', 'backslashreplace'), \"ASCII\")\n\twant = str(pldecode(want).encode('ASCII', 'backslashreplace'), \"ASCII\")\n\n\t# Handle the common case first, for efficiency:\n\t# if they're string-identical, always return true.\n\tif got == want:\n\t\treturn True\n\n\t# If a line in got contains only spaces, then remove the\n\t# spaces.\n\tgot = re.sub('(?m)^\\s*?$', '', got)\n\tif got == want:\n\t\treturn True\n\t# This flag causes doctest to ignore any differences in the\n\t# contents of whitespace strings.  Note that this can be used\n\t# in conjunction with the ELLIPSIS flag.\n\tif True : # we want normelized white spaces\n\t\tgot = ' '.join(got.split())\n\t\twant = ' '.join(want.split())\n\t\tif got == want:\n\t\t\treturn True\n\t# We didn't find any match; return false.\n\treturn False\n\n\ndef pldecode(s):\n\tif type(s) is str:\n\t\treturn s\n\telse:\n\t\treturn str(s.decode(encoding=\"utf-8\", errors=\"strict\"))\n\ndef dodump(dr,ev=0):\n\t#for key in ['execution','feedback','error','other','error']:\n\t#\tdr[key]= '<br>'.join(dr[key].split(\"\\n\"))\n\tprint(json.dumps(dr))\n\tsys.exit(ev)\n\n\ndef success(message):\n\tdico_reponse = { \"success\": True ,\n\t\"execution\" : \"\",\n\t\"feedback\": \"# Bravo **vous** *avez*\\n\\n reussit l'exercice\\n\"+message,\n\t\"other\": \"\",\"error\":\"\"}\n\tif globtaboook :# usage d'un mot taboo\n\t\tdico_reponse[\"success\"]= False\n\t\tdico_reponse[\"feedback\"] += \"L'execution est bonne mais les taboo ne sont pas respect\u00e9s\\n recommancez sans les mots clefs :\"+getpldic()[\"taboo\"]\n\tdodump(dico_reponse)\n\n\ndef compileerror(message):\n\t\"\"\"\n\tcompileerror(\"les messages du compilateur pour l'execution \")\n\n\t\"\"\"\n\tdico_reponse = { \"success\": False ,\n\t \"feedback\": \"# Erreur de compilation \\n Le compilateur \u00e0 d\u00e9tect\u00e9 une erreur\\n il faut la corriger\\n\"+pldecode(message),\"errormessages\" : \"\" , \"other\": \"\",\"error\":\"\",\"execution\":\"\" }\n\tdodump(dico_reponse)\n\ndef erreurdexecution(message):\n\t\"\"\"\n\tappellez cette fonction quand il y a une exception dans l'execution\n\ti.e. stderr non vide\n\tappeller avec la concat\u00e9nation de stdout et sdterr\n\t\"\"\"\n\tdico_reponse = { \"success\": False ,\n\t \"feedback\": \"# Erreur \u00e0 l'ex\u00e9cution\\n Il semble qu'une erreur de programmation c'est gliss\u00e9e dans votre code \\n# Sortie standard\\n\"+str(message),\"errormessages\" : \"\" , \"other\": \"\",\"error\":\"\",\"execution\":\"\" }\n\tdodump(dico_reponse)\n\ndef failure(message):\n\t\"\"\"\n\tUne erreur d'excution r\u00e9sultat non conforme aux attentes\n\tle message contient le nombre de tests r\u00e9ussis et le test en \u00e9chec\n\t\"\"\"\n\tdico_reponse = { \"success\": False , \"errormessages\" : \"\" ,\n\t \"feedback\": \"#Mauvais r\u00e9sultat \\n Il n'y a pas d'erreur dans votre code \\n Mais il ne calcul pas le r\u00e9sultat attendu\\n # Execution \\n \"+str(message), \"other\":\"\" ,\"error\":\"\",\"execution\":\"\"}\n\tdodump(dico_reponse)\n\ndef plateform(dexec,feedback=\"# Erreur Plateforme \\n Un probl\u00e8me de la plateforme\\\\n parlez en au professeur\\\\n passez \u00e0 l'exercice suivant\"):\n\tfeedback += \"\\n# Execution \\n\" + dexec['stdout']\n\tfeedback += \"\\# Erreurs \\n\"+ dexec['stderr']+\"\\n\"+error \n\tdico_reponse = { \"success\": True , \"errormessages\" : \"\",\"feedback\": feedback, \"other\": \"\",\"error\":\"\",\"execution\": \"\"\n\t\t}\n\tdodump(dico_reponse,ev=1)\n\n\n\n\ndef exectojson(target,infile=None,jsonfile=None,timeout=1):\n\t\"\"\"\n\texectojson execute the shell process\n\tpython3 target <infile\n\tcatches the result, stdout, stderr of this process and\n\treturn a dictionnary with these three values\n\tif jsonfile != None:\n\t\ta jsondump of the dictionnary is done in the file named jsonfile\n\tthe process is kill after a timeout (1 default) seconds\n\n\n\t\t>>> d=exectojson(\"xx.py\",infile=\"entrrrrrrree.tex\")\n\t\t>>> d['result']==False\n\t\tTrue\n\t\t>>> d['stdout'] == \"PlateForme IO ERROR\"\n\t\tTrue\n\n\t\t>>> f=open(\"entree.tex\",\"r\")\n\t\t>>> d=exectojson(\"tolong.py\",infile=\"entree.tex\")\n\t\t>>> d['result']\n\t\tFalse\n\t\t>>> d['stdout']\n\t\t\"temps d'execution trop long\"\n\n\t\t>>> d=exectojson(\"xx.py\",infile=\"entree.tex\")\n\t\t>>> d['result']\n\t\tTrue\n\t\t>>> d['stdout']\n\t\tb\"procesus fils\\\\nj'ai lu  PAS DE PROBLEM DE LECTURE\\\\n\"\n\t\t>>> d=exectojson(\"xx.py\") # pas d'input\n\t\t>>> d['result']\n\t\tFalse\n\t\t>>> d['stdout']\n\t\tb'procesus fils\\\\n'\n\t\t>>> d=exectojson(['-m','doctest','testofdoc.py'])\n\t\t>>> d['result']\n\t\tTrue\n\n\t\"\"\"\n\t# TODO can i check the existance of python3 ?\n\t# CHECKME no options\n\tif isinstance(target, str):\n\t\targs=['python3',target]\n\telif isinstance(target, list):\n\t\targs=['python3']\n\t\targs.extend(target)\n\telse:\n\t\traise TypeError(target)\n\ttry:\n\t\tif infile:\n\t\t\tentry = open(infile, \"rb\")\n\t\t\tcp = subprocess.run(args, input=entry.read(),\n\t\t\t\tstdout=subprocess.PIPE,stderr=subprocess.PIPE,\n\t\t\t\ttimeout=timeout)\n\t\telse:\n\t\t\tcp = subprocess.run(args, stdin=subprocess.DEVNULL, stdout=subprocess.PIPE,stderr=subprocess.PIPE, timeout=timeout)\n\t\tdico = {\"plateforme\":True,\"stderr\":cp.stderr,\"result\":cp.returncode==0,\"stdout\":cp.stdout}\n\texcept (OSError, IOError) as e:\n\t\tdico = {\"plateforme\":False,\"stderr\":e,\"result\":False,\"stdout\":\"PlateForme IO ERROR\"}\n\texcept subprocess.TimeoutExpired as toe:\n\t\tdico = {\"plateforme\":True,\"stderr\":toe,\"result\":False,\"stdout\":\"temps d'execution trop long\"}\n\n\tif jsonfile:\n\t\twith open(jsonfile,\"w\") as jsf:\n\t\t\tjson.dump(dico, fp=jsf,sort_keys=True)\n\treturn(dico)\n\ndef compiletest():\n\t\"\"\"\n\t>>> _createStudentCode(\"@ <- \u00e7a grosse erreur de compile \")\n\t>>> compiletest()\n\tTraceback (most recent call last):\n\t...\n\tSystemExit: 0\n\t>>> _createStudentCode(\"print('titi') \")\n\t>>> compiletest()\n\tTrue\n\t\"\"\"\n\tEEE=None\n\timport py_compile\n\ttry:\n\t\tx= py_compile.compile(\"student.py\",doraise=True)\n\texcept Exception as EE:\n\t\tEEE=EE\n\telse:\n\t\treturn True\n\n\tcompileerror(str(EEE))\n\treturn False # inatt\u00e9gnable\n\n\n\n\n\n\n\ndef createInputFile(pld,lastgenerated=True):\n\t\"\"\"\n\tcreates a file \"input.txt\" in current directory\n\twith the inputgenerator if it exist\n\twith the input field if it exist\n\twith input0 to input9 FIXME in this order\n\tthe inputgenerator is considered random\n\t\tand new file will create each call\n\n\t>>> import os.path\n\t>>> if os.path.isfile(\"input.txt\"): os.remove(\"input.txt\")\n\t>>> plk={\"inputgenerator\":\"import random\\\\nfor  n in range(10):\\\\n  print(random.randint(4,123))\",\"input\":None}\n\t>>> createInputFile(plk,lastgenerated=True)\n\tTrue\n\t>>> \"inputgenerator\" in plk\n\tFalse\n\t>>> os.path.isfile(\"input.txt\")\n\tTrue\n\t>>> createInputFile({\"inputgenerator\":\"import random\\\\nfor  n in range(10):\\\\n  print(random.randint(4,123))\",\"input\":\"Toto\"}) # ambiguit\u00e9 entre input et inputgenerator\n\tTraceback (most recent call last):\n\t...\n\tSystemExit: 0\n\t>>> if os.path.isfile(\"input.txt\"): os.remove(\"input.txt\")\n\t>>> createInputFile({\"input\": b\"1\\\\n2\\\\n3\\\\n4\\\\n\"})\n\tTrue\n\t>>> os.path.isfile(\"input.txt\")\n\tTrue\n\t>>> createInputFile({\"input4\": b\"5\\\\n5\\\\n5\\\\n5\\\\n\"})\n\tTrue\n\t>>> createInputFile({})\n\tFalse\n\t\"\"\"\n\n\tif 'inputgenerator' in pld:\n\t\twith open(\"inputgen.py\",\"w\") as ig:\n\t\t\tprint(pld[\"inputgenerator\"],file=ig)\n\t\td=exectojson(\"inputgen.py\")\n\t\tif  'input' in pld and pld['input'] != None:\n\t\t\t# TODO remonter une erreur a l'auteur du test\n\t\t\tfailure(\"INPUT ET INPUTGENERATOR AMBIGUITE\\\\n\")\n\t\tpld['input']=d['stdout'] # on \u00e9crasse le input\n\t\tif lastgenerated:\n\t\t\tdel pld['inputgenerator'] # doit repondre faux la prochaine fois\n\telif not 'input' in pld:\n\t\tfor i in range(0,10):\n\t\t\ts='input'+str(i)\n\t\t\tif s in pld:\n\t\t\t\tpld['input']=pld[s]\n\t\t\t\tdel pld[s]\n\t\t\t\tbreak\n\n\tif 'input' in pld:\n\t\twith open(\"input.txt\",\"w\") as it :\n\t\t\tprint(pldecode(pld['input']),file=it)\n\t\t\tdel pld['input']\n\t\treturn True\n\telse:\n\t\treturn False # retourne faux si pas de input ou si fin des inputs pr\u00e9d\u00e9finis\n\n\ndef compareexecution():\n\t\"\"\"\n\tcheck the execution of student with input = input.txt\n\tagainst the execution of soluce with input = input.txt\n\t\"\"\"\n\tdt= exectojson(\"soluce.py\",infile=\"input.txt\")\n\tds= exectojson(\"student.py\",infile=\"input.txt\")\n\tif check_output(dt['stdout'],ds['stdout']):\n\t\t# TODO\n\t\treturn True,\"\",\"\"\n\telse:\n\t\treturn False,str(dt['stdout']),str(ds['stdout'])\n\ndef dumpdic(dic):\n\timport json\n\tf=open(\"pl.json\",\"w\")\n\tprint(json.dump(dic,f,sort_keys=True))\n\tf.close()\n\treturn\n\ndef _createStudentCode(code):\n\tf=open(\"student.py\",\"w\")\n\tprint(code,file=f)\n\tf.close()\n\n\ndef grade():\n\t\"\"\"\n\t# pour que ce test fonctionne il faut un fichier pl.json\n\t>>> dumpdic({\"input\":\"1\\\\n2\\\\n\",\"expectedoutput\":\"1\\\\n2\\\\n\"})\n\tNone\n\t>>> _createStudentCode(\"print(input())\\\\nprint(input())\\\\n\")\n\t>>> d=grade()\n\tTraceback (most recent call last):\n\t...\n\tSystemExit: 0\n\t>>>\n\t\"\"\"\n\tpld=getpldic()\n\tif 'taboo' in pld:\n\t\tchecktaboo(pld['taboo'])\n\tcompiletest()\n\tif 'expectedoutput' in pld:\n\t\tif not createInputFile(pld): # il n'y a pas de fichier d'entr\u00e9e\n\t\t\td=exectojson(\"student.py\")\n\t\telse:\n\t\t\td=exectojson(\"student.py\",infile=\"input.txt\")\n\t\tif check_output(pld['expectedoutput'],d['stdout']):\n\t\t\tsuccess(pld['expectedoutput'])\n\t\telse:\n\t\t\tmessage = \"Votre script ne produit pas la bonne sortie\\nsortie attendue:\\n\" + pld['expectedoutput']\n\t\t\tmessage += \"\\nsortie optenue:\\n\" + pldecode( d['stdout'])\n\t\t\terreurdexecution(message)\n\telif 'pltest' in pld:\n\t\t# copier \u00e0 la fin de student.py le doctest puis lancer la commande\n\t\t# python3 -m doctest student.py\n\t\tplateform(message=\"pas IMPLEMENTE ENCORE \\\\n\")\n\telif 'soluce' in pld:\n# il faut pour tous les input* verifier que l'execution de student celle de soluce\n# ou bien faire inputgeneratorcalls appels \u00e0 inputgenerator et verifier la m\u00eame chose\n\t\tNBT=0 # NOMBRE DE TESTS REUSSIT\n\t\twhile createInputFile(pld) :\n\t\t\tr,want,got = compareexecution()\n\t\t\tif not r : # echec d'un test\n\t\t\t\tmessage= \"# \"+ str(NBT)+\" tests r\u00e9ussits\\n\"\n\t\t\t\tmessage += \"entree:\\n\"\n\t\t\t\tmessage += open(\"input.txt\",\"r\").read()\n\t\t\t\tmessage += \"\\nsortie attendue:\\n\" + str(want)\n\t\t\t\tmessage += \"\\nsortie optenue:\\n\" + str(got)\n\t\t\t\tfailure(message)\n\t\t\telse:\n\t\t\t\tNBT+=1\n\t\tmessage=\"%d tests pass\u00e9 avec succes \" % NBT\n\t\tsuccess(message)\n\telse:\n\t\tplateform(message=\"Utilisez une m\u00e9thode d'\u00e9valuation expectedoutput,pltest,soluce\\\\n\")\n\n\ndef main(args):\n\tprint(\"ce fichier n'est pas un script principal\",file=sys.stderr)\n\treturn 1\n\nif __name__ == '__main__':\n    import sys\n    sys.exit(main(sys.argv))\n"
        }
    ],
    "grader": "\nfrom utils import grade\ngrade()\n",
    "pl_path": "python\/IUT\/TP1\/operator001.pl",
    "repository": "https:\/\/github.com\/plgitlogin\/plbank",
    "tag": "print|input|operator.mod|operator.floordiv",
    "text": "\n\n# Operator  \/\/ et % \n\nJoelle a des poules tout les matins elle ramasse les oeufs et les mets dans des boites.\n\nQuand elle a fini de ramasser les oeufs elle appelle sont fils en lui donnant le nombre d'oeuf, il doit calculer le nombre de boites de 6 oeufs et le nombre d'oeufs restants.\n\nAidons le avec \/\/ qui est la division enti\u00e8re et % (op\u00e9rateur modulo) qui calcul le reste de la division enti\u00e8re. \n\n\n\n\n",
    "code": "\nnbreoeufs = int( input(\"saisissez le nombre d'oeufs :\") )\n\nb=  # votre op\u00e9ration \nr=  # votre op\u00e9ration\n\nprint(\"Il faut \"+ b + \"boites.\")\nprint(\"il restera \"+ r + \"oeufs.\") \n\n\n",
    "inputgenerator": "\nfrom random import randint\n\nprint(randint(10,100)*6+randint(1,6))\n",
    "soluce": "\nnbroeufs = int( input(\"saisissez le nombre d'oeufs :\") )\n\nprint(\"Il faut \"+ nbroeufs \/\/ 6 + \"boites.\")\nprint(\"il restera \"+ nbroeufs % 6 + \"oeufs.\") \n\n"
}
